import { Attribute, SchemaEntityWithId, Builder, Entity, SubscriptionEvent, BuilderStoreData, BuilderStoreEvent, BuilderStore, Schema, InterpreterStoreEvent, InterpreterStoreOptions, InterpreterStore, InterpreterStoreData, EntitiesValues } from '@coltorapps/builder';
import { LazyExoticComponent } from 'react';

type AttributeForRender<TAttribute extends Attribute> = {
    name: TAttribute["name"];
    value: Awaited<ReturnType<TAttribute["validate"]>>;
    error?: unknown;
};
type AttributeComponentProps<TAttribute extends Attribute = Attribute> = {
    attribute: AttributeForRender<TAttribute>;
    entity: SchemaEntityWithId;
    validateValue: () => Promise<void>;
    resetError: () => void;
    setValue: (value: Awaited<ReturnType<TAttribute["validate"]>>) => void;
};
type AttributeComponent<TAttribute extends Attribute = Attribute> = (props: AttributeComponentProps<TAttribute>) => JSX.Element | null;
type EntitiesAttributesComponents<TBuilder extends Builder = Builder> = {
    [K in TBuilder["entities"][number]["name"]]: (() => JSX.Element | null) | LazyExoticComponent<() => JSX.Element | null>;
};
declare function createAttributeComponent<TAttribute extends Attribute>(attribute: TAttribute, render: AttributeComponent<TAttribute>): () => JSX.Element | null;

type EntityForRender<TEntity extends Entity = Entity> = SchemaEntityWithId<Builder<[TEntity]>> & {
    value?: Awaited<ReturnType<TEntity["validate"]>>;
    error?: unknown;
};
type EntityComponentProps<TEntity extends Entity = Entity> = {
    entity: EntityForRender<TEntity>;
    children?: JSX.Element[];
    setValue: (value?: Awaited<ReturnType<TEntity["validate"]>>) => void;
    validateValue: () => Promise<void>;
    resetError: () => void;
    resetValue: () => void;
    clearValue: () => void;
};
type EntityComponent<TEntity extends Entity = Entity> = (props: EntityComponentProps<TEntity>) => JSX.Element | null;
declare function createEntityComponent<TEntity extends Entity>(_entity: TEntity, render: EntityComponent<TEntity>): EntityComponent<TEntity>;
type EntitiesComponents<TBuilder extends Builder = Builder> = {
    [K in TBuilder["entities"][number]["name"]]: EntityComponent<Extract<TBuilder["entities"][number], {
        name: K;
    }>> | LazyExoticComponent<EntityComponent<Extract<TBuilder["entities"][number], {
        name: K;
    }>>>;
};
type GenericEntityProps<TBuilder extends Builder = Builder> = {
    entity: EntityForRender<TBuilder["entities"][number]>;
    children: JSX.Element;
};
type GenericEntityComponent<TBuilder extends Builder = Builder> = (props: GenericEntityProps<TBuilder>) => JSX.Element | null;

type EventsListeners<TEvent extends SubscriptionEvent> = {
    [K in `on${TEvent["name"]}`]?: K extends `on${infer REventName}` ? (payload: Extract<TEvent, {
        name: REventName;
    }>["payload"]) => void : never;
};

declare function useBuilderStore<TBuilder extends Builder>(builder: TBuilder, options?: {
    initialData?: Partial<BuilderStoreData<TBuilder>>;
    events?: EventsListeners<BuilderStoreEvent<TBuilder>>;
}): BuilderStore<TBuilder>;
declare function useBuilderStoreData<TBuilder extends Builder>(builderStore: BuilderStore<TBuilder>, shouldUpdate?: (events: Array<BuilderStoreEvent<TBuilder>>) => boolean): BuilderStoreData<TBuilder>;
declare function BuilderEntity<TBuilder extends Builder>(props: {
    entityId: string;
    components: EntitiesComponents<TBuilder>;
    children?: GenericEntityComponent<TBuilder>;
    builderStore: BuilderStore<TBuilder>;
}): JSX.Element | null;
declare function BuilderEntities<TBuilder extends Builder>(props: {
    builderStore: BuilderStore<TBuilder>;
    components: EntitiesComponents<TBuilder>;
    children?: GenericEntityComponent<TBuilder>;
}): JSX.Element[];
declare function BuilderEntityAttributes<TBuilder extends Builder>(props: {
    builderStore: BuilderStore<TBuilder>;
    entityId: string;
    components: EntitiesAttributesComponents<TBuilder>;
}): JSX.Element;

declare function useInterpreterStore<TBuilder extends Builder>(builder: TBuilder, schema: Schema<TBuilder>, options?: {
    events?: EventsListeners<InterpreterStoreEvent<TBuilder>>;
} & InterpreterStoreOptions<TBuilder>): InterpreterStore<TBuilder>;
declare function useInterpreterStoreData<TBuilder extends Builder>(interpreterStore: InterpreterStore<TBuilder>, shouldUpdate?: (events: Array<InterpreterStoreEvent<TBuilder>>) => boolean): InterpreterStoreData<TBuilder>;
declare function InterpreterEntity<TBuilder extends Builder>(props: {
    entityId: string;
    components: EntitiesComponents<TBuilder>;
    children?: GenericEntityComponent<TBuilder>;
    interpreterStore: InterpreterStore<TBuilder>;
}): JSX.Element | null;
declare function InterpreterEntities<TBuilder extends Builder>(props: {
    interpreterStore: InterpreterStore<TBuilder>;
    components: EntitiesComponents<TBuilder>;
    children?: GenericEntityComponent<TBuilder>;
}): JSX.Element[];
/**
 * @deprecated Use `InterpreterEntities` instead of `Interpreter`. The alias will be removed in future versions.
 */
declare const Interpreter: typeof InterpreterEntities;
declare function useInterpreterEntitiesValues<TBuilder extends Builder>(interpreterStore: InterpreterStore<TBuilder>, entitiesIds?: Array<string>): EntitiesValues<TBuilder>;

export { type AttributeComponentProps, BuilderEntities, BuilderEntity, BuilderEntityAttributes, type EntitiesAttributesComponents, type EntitiesComponents, type EntityComponent, type EntityComponentProps, type GenericEntityComponent, type GenericEntityProps, Interpreter, InterpreterEntities, InterpreterEntity, createAttributeComponent, createEntityComponent, useBuilderStore, useBuilderStoreData, useInterpreterEntitiesValues, useInterpreterStore, useInterpreterStoreData };
