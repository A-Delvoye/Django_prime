type UndefinedKeys<T> = {
    [K in keyof T]: undefined extends T[K] ? K : never;
}[keyof T];
type NonUndefinedKeys<T> = {
    [K in keyof T]: undefined extends T[K] ? never : K;
}[keyof T];
type OptionalPropsIfUndefined<T> = {
    [K in UndefinedKeys<T>]?: T[K];
} & {
    [K in NonUndefinedKeys<T>]: T[K];
};
type KeyofUnion<T> = T extends unknown ? keyof T : never;

declare const schemaValidationErrorCodes: {
    readonly InvalidRootFormat: "InvalidRootFormat";
    readonly DuplicateRootId: "DuplicateRootId";
    readonly DuplicateChildId: "DuplicateChildId";
    readonly RootEntityWithParent: "RootEntityWithParent";
    readonly EmptyRoot: "EmptyRoot";
    readonly NonexistentEntityId: "NonexistentEntityId";
    readonly InvalidEntitiesFormat: "InvalidEntitiesFormat";
    readonly MissingEntityType: "MissingEntityType";
    readonly UnknownEntityType: "UnknownEntityType";
    readonly InvalidChildrenFormat: "InvalidChildrenFormat";
    readonly InvalidSchema: "InvalidSchema";
    readonly NonexistentEntityParent: "NonexistentEntityParent";
    readonly MissingEntityAttributes: "MissingEntityAttributes";
    readonly InvalidEntityAttributesFormat: "InvalidEntityAttributesFormat";
    readonly UnknownEntityAttributeType: "UnknownEntityAttributeType";
    readonly InvalidEntityAttributes: "InvalidEntityAttributes";
    readonly InvalidEntitiesAttributes: "InvalidEntitiesAttributes";
    readonly SelfEntityReference: "SelfEntityReference";
    readonly ChildNotAllowed: "ChildNotAllowed";
    readonly EntityChildrenMismatch: "EntityChildrenMismatch";
    readonly ParentRequired: "ParentRequired";
    readonly ParentNotAllowed: "ParentNotAllowed";
    readonly EntityParentMismatch: "EntityParentMismatch";
    readonly UnreachableEntity: "UnreachableEntity";
};
type SchemaValidationErrorCode = (typeof schemaValidationErrorCodes)[keyof typeof schemaValidationErrorCodes];
type SchemaValidationErrorReason = {
    code: typeof schemaValidationErrorCodes.InvalidRootFormat;
    payload: {
        root?: unknown;
    };
} | {
    code: typeof schemaValidationErrorCodes.DuplicateRootId;
    payload: {
        entityId: string;
    };
} | {
    code: typeof schemaValidationErrorCodes.DuplicateChildId;
    payload: {
        entityId: string;
    };
} | {
    code: typeof schemaValidationErrorCodes.EmptyRoot;
} | {
    code: typeof schemaValidationErrorCodes.NonexistentEntityId;
    payload: {
        entityId: string;
    };
} | {
    code: typeof schemaValidationErrorCodes.InvalidEntitiesFormat;
    payload: {
        entities?: unknown;
    };
} | {
    code: typeof schemaValidationErrorCodes.MissingEntityType;
    payload: {
        entityId: string;
    };
} | {
    code: typeof schemaValidationErrorCodes.UnknownEntityType;
    payload: {
        entityId: string;
        entityType: string;
    };
} | {
    code: typeof schemaValidationErrorCodes.NonexistentEntityParent;
    payload: {
        entityId: string;
        entityParentId: string;
    };
} | {
    code: typeof schemaValidationErrorCodes.MissingEntityAttributes;
    payload: {
        entityId: string;
    };
} | {
    code: typeof schemaValidationErrorCodes.InvalidEntityAttributesFormat;
    payload: {
        entityId: string;
        entityAttributes: unknown;
    };
} | {
    code: typeof schemaValidationErrorCodes.UnknownEntityAttributeType;
    payload: {
        entityId: string;
        attributeName: string;
    };
} | {
    code: typeof schemaValidationErrorCodes.SelfEntityReference;
    payload: {
        entityId: string;
    };
} | {
    code: typeof schemaValidationErrorCodes.InvalidChildrenFormat;
    payload: {
        entityId: string;
    };
} | {
    code: typeof schemaValidationErrorCodes.ChildNotAllowed;
    payload: {
        entityId: string;
        childId: string;
    };
} | {
    code: typeof schemaValidationErrorCodes.RootEntityWithParent;
    payload: {
        entityId: string;
    };
} | {
    code: typeof schemaValidationErrorCodes.EntityChildrenMismatch;
    payload: {
        entityId: string;
        childId: string;
    };
} | {
    code: typeof schemaValidationErrorCodes.EntityParentMismatch;
    payload: {
        entityId: string;
        parentId: string;
    };
} | {
    code: typeof schemaValidationErrorCodes.ParentRequired;
    payload: {
        entityId: string;
    };
} | {
    code: typeof schemaValidationErrorCodes.ParentNotAllowed;
    payload: {
        entityId: string;
        parentId: string;
    };
} | {
    code: typeof schemaValidationErrorCodes.UnreachableEntity;
    payload: {
        entityId: string;
    };
} | {
    code: typeof schemaValidationErrorCodes.InvalidEntityAttributes;
    payload: {
        entityId: string;
        attributesErrors: EntityAttributesErrors;
    };
} | {
    code: typeof schemaValidationErrorCodes.InvalidEntitiesAttributes;
    payload: {
        entitiesAttributesErrors: EntitiesAttributesErrors;
    };
} | {
    code: typeof schemaValidationErrorCodes.InvalidSchema;
    payload: {
        schemaError: unknown;
    };
};
declare class SchemaValidationError extends Error {
    reason: SchemaValidationErrorReason;
    constructor(reason: SchemaValidationErrorReason);
}
type BaseSchemaEntity<TBuilder extends Builder = Builder, TExtend = object> = {
    [K in TBuilder["entities"][number]["name"]]: {
        type: K;
        attributes: OptionalPropsIfUndefined<AttributesValues<Extract<TBuilder["entities"][number], {
            name: K;
        }>["attributes"]>>;
        parentId?: string;
    } & TExtend;
}[TBuilder["entities"][number]["name"]];
type SchemaEntity<TBuilder extends Builder = Builder> = BaseSchemaEntity<TBuilder, {
    children?: Array<string>;
}>;
type Schema<TBuilder extends Builder = Builder> = {
    entities: Record<string, SchemaEntity<TBuilder>>;
    root: ReadonlyArray<string>;
};
type SchemaEntityWithId<TBuilder extends Builder = Builder> = SchemaEntity<TBuilder> & {
    id: string;
};
type SchemValidationResult<TBuilder extends Builder> = {
    data: Schema<TBuilder>;
    success: true;
} | {
    reason: SchemaValidationErrorReason;
    success: false;
};
declare function validateSchemaShape<TBuilder extends Builder>(schema: unknown, builder: TBuilder): SchemValidationResult<TBuilder>;
type EntityAttributesErrors<TBuilder extends Builder = Builder> = Partial<Record<KeyofUnion<SchemaEntity<TBuilder>["attributes"]>, unknown>>;
type EntitiesAttributesErrors<TBuilder extends Builder = Builder> = Record<string, EntityAttributesErrors<TBuilder>>;
declare function validateSchema<TBuilder extends Builder>(schema: unknown, builder: TBuilder): Promise<SchemValidationResult<TBuilder>>;

type AttributeContext = {
    schema: Schema;
    entity: SchemaEntityWithId;
};
type Attribute<TName extends string = string, TValue = unknown> = {
    name: TName;
    validate: (value: unknown, context: AttributeContext) => TValue;
};
type AttributesValues<TAttributes extends ReadonlyArray<Attribute> = ReadonlyArray<Attribute>> = {
    [K in TAttributes[number]["name"]]: Awaited<ReturnType<Extract<TAttributes[number], {
        name: K;
    }>["validate"]>>;
};
declare function createAttribute<const TName extends string, TValue>(options: Attribute<TName, TValue>): Attribute<TName, TValue>;

type EntityContext<TAttributes extends ReadonlyArray<Attribute>> = {
    entity: {
        id: string;
        attributes: AttributesValues<TAttributes>;
        children?: Array<string>;
        parentId?: string;
    };
    entitiesValues: Record<string, unknown>;
};
type AttributesExtensions<TEntity extends Entity = Entity> = {
    [K in TEntity["attributes"][number]["name"]]?: {
        validate?: (value: unknown, context: {
            schema: Schema;
            entity: SchemaEntityWithId<Builder<[TEntity]>>;
            validate: (value: unknown) => ReturnType<Extract<TEntity["attributes"][number], {
                name: K;
            }>["validate"]>;
        }) => AttributesValues<TEntity["attributes"]>[K] | Promise<AttributesValues<TEntity["attributes"]>[K]>;
    };
};
type Entity<TName extends string = string, TAttributes extends ReadonlyArray<Attribute> = ReadonlyArray<Attribute>, TValue = unknown, TParentRequired extends boolean = boolean, TChildrenAllowed extends boolean = boolean> = {
    name: TName;
    attributes: TAttributes;
    valueAllowed: boolean;
    childrenAllowed: TChildrenAllowed;
    parentRequired: TParentRequired;
    attributesExtensions: AttributesExtensions<Entity<TName, TAttributes>>;
    validate: (value: unknown, context: EntityContext<TAttributes>) => TValue;
    defaultValue: (context: EntityContext<TAttributes>) => Awaited<TValue> | undefined;
    shouldBeProcessed: (context: EntityContext<TAttributes>) => boolean;
};
type OptionalEntityArgs = "attributes" | "validate" | "defaultValue" | "shouldBeProcessed" | "childrenAllowed" | "attributesExtensions" | "parentRequired";
declare function createEntity<const TName extends string, const TAttributes extends ReadonlyArray<Attribute>, TValue, const TChildrenAllowed extends boolean = false, const TParentRequired extends boolean = false>(options: Omit<Entity<TName, TAttributes, TValue, TParentRequired, TChildrenAllowed>, OptionalEntityArgs | "valueAllowed"> & Partial<Pick<Entity<TName, TAttributes, TValue, TParentRequired, TChildrenAllowed>, OptionalEntityArgs>>): Entity<TName, TAttributes, TValue, TParentRequired, TChildrenAllowed>;

type EntitiesExtensions<TEntities extends ReadonlyArray<Entity> = ReadonlyArray<Entity>> = {
    [K in TEntities[number]["name"]]?: {
        childrenAllowed?: boolean | ReadonlyArray<TEntities[number]["name"]>;
        parentRequired?: boolean;
        allowedParents?: ReadonlyArray<TEntities[number]["name"]>;
        attributes?: {
            [K2 in Extract<TEntities[number], {
                name: K;
            }>["attributes"][number]["name"]]?: {
                validate?: (value: unknown, context: {
                    schema: Schema<Builder<TEntities>>;
                    entity: SchemaEntityWithId<Builder<[Extract<TEntities[number], {
                        name: K;
                    }>]>>;
                    validate: (value: unknown) => ReturnType<Extract<Extract<TEntities[number], {
                        name: K;
                    }>["attributes"][number], {
                        name: K2;
                    }>["validate"]>;
                }) => AttributesValues<Extract<TEntities[number], {
                    name: K;
                }>["attributes"]>[K2] | Promise<AttributesValues<Extract<TEntities[number], {
                    name: K;
                }>["attributes"]>[K2]>;
            };
        };
    };
};
type Builder<TEntities extends ReadonlyArray<Entity> = ReadonlyArray<Entity>, TEntitiesExtensions extends EntitiesExtensions<TEntities> = EntitiesExtensions<[]>> = {
    entities: TEntities;
    generateEntityId(): string;
    validateEntityId(id: string): void;
    validateSchema(schema: Schema<Builder<TEntities, TEntitiesExtensions>>): Promise<Schema<Builder<TEntities, TEntitiesExtensions>>> | Schema<Builder<TEntities, TEntitiesExtensions>>;
    entitiesExtensions: TEntitiesExtensions;
};
type OptionalBuilderArgs = "validateSchema" | "generateEntityId" | "entitiesExtensions" | "validateEntityId";
declare function createBuilder<const TEntities extends ReadonlyArray<Entity>, const TEntitiesExtensions extends EntitiesExtensions<TEntities> = EntitiesExtensions<TEntities>>(options: Omit<Builder<TEntities, TEntitiesExtensions>, OptionalBuilderArgs> & Partial<Pick<Builder<TEntities, TEntitiesExtensions>, OptionalBuilderArgs>>): Builder<TEntities, TEntitiesExtensions>;

type Listener<TData, TEvent extends SubscriptionEvent> = {
    (data: TData, events: Array<TEvent>): void;
};
type Subscribe<TData, TEvent extends SubscriptionEvent> = {
    (listener: Listener<TData, TEvent>): () => void;
};
type SubscriptionEvent<TName extends string = string, TPayload = unknown> = {
    name: TName;
    payload: TPayload;
};

type InternalBuilderStoreEntity<TBuilder extends Builder = Builder> = BaseSchemaEntity<TBuilder, {
    children?: Set<string>;
}>;
type BuilderStoreData<TBuilder extends Builder = Builder> = {
    schema: Schema<TBuilder>;
    entitiesAttributesErrors: EntitiesAttributesErrors<TBuilder>;
    schemaError: unknown;
};
declare const builderStoreEventsNames: {
    readonly EntityAdded: "EntityAdded";
    readonly EntityUpdated: "EntityUpdated";
    readonly EntityAttributeUpdated: "EntityAttributeUpdated";
    readonly EntityDeleted: "EntityDeleted";
    readonly EntityCloned: "EntityCloned";
    readonly RootUpdated: "RootUpdated";
    readonly EntityAttributeErrorUpdated: "EntityAttributeErrorUpdated";
    readonly SchemaErrorUpdated: "SchemaErrorUpdated";
    readonly SchemaUpdated: "SchemaUpdated";
    readonly DataSet: "DataSet";
};
type BuilderStoreEventName = (typeof builderStoreEventsNames)[keyof typeof builderStoreEventsNames];
type BuilderStoreEvent<TBuilder extends Builder = Builder> = SubscriptionEvent<typeof builderStoreEventsNames.EntityAdded, {
    entity: SchemaEntityWithId<TBuilder>;
}> | SubscriptionEvent<typeof builderStoreEventsNames.EntityUpdated, {
    entity: SchemaEntityWithId<TBuilder>;
}> | SubscriptionEvent<typeof builderStoreEventsNames.EntityAttributeUpdated, {
    entity: SchemaEntityWithId<TBuilder>;
    attributeName: KeyofUnion<SchemaEntity<TBuilder>["attributes"]>;
}> | SubscriptionEvent<typeof builderStoreEventsNames.EntityDeleted, {
    entity: SchemaEntityWithId<TBuilder>;
}> | SubscriptionEvent<typeof builderStoreEventsNames.EntityCloned, {
    entity: SchemaEntityWithId<TBuilder>;
    entityClone: SchemaEntityWithId<TBuilder>;
    isCloneOrigin: boolean;
}> | SubscriptionEvent<typeof builderStoreEventsNames.DataSet, {
    data: BuilderStoreData<TBuilder>;
}> | SubscriptionEvent<typeof builderStoreEventsNames.EntityAttributeErrorUpdated, {
    entity: SchemaEntityWithId<TBuilder>;
    attributeName: KeyofUnion<SchemaEntity<TBuilder>["attributes"]>;
    error: unknown;
}> | SubscriptionEvent<typeof builderStoreEventsNames.SchemaErrorUpdated, {
    error: unknown;
}> | SubscriptionEvent<typeof builderStoreEventsNames.SchemaUpdated, {
    schema: Schema<TBuilder>;
}> | SubscriptionEvent<typeof builderStoreEventsNames.RootUpdated, {
    root: BuilderStoreData<TBuilder>["schema"]["root"];
}>;
declare function createBuilderStore<TBuilder extends Builder>(builder: TBuilder, options?: {
    initialData?: Partial<BuilderStoreData<TBuilder>>;
}): BuilderStore<TBuilder>;
type BuilderStore<TBuilder extends Builder = Builder> = {
    getData(): BuilderStoreData<TBuilder>;
    getSchema(): BuilderStoreData<TBuilder>["schema"];
    getEntitiesAttributesErrors(): BuilderStoreData<TBuilder>["entitiesAttributesErrors"];
    getSchemaError(): BuilderStoreData<TBuilder>["schemaError"];
    setData(data: BuilderStoreData<TBuilder>): void;
    subscribe(...args: Parameters<Subscribe<BuilderStoreData<TBuilder>, BuilderStoreEvent<TBuilder>>>): ReturnType<Subscribe<BuilderStoreData<TBuilder>, BuilderStoreEvent<TBuilder>>>;
    builder: TBuilder;
    addEntity(payload: InternalBuilderStoreEntity<TBuilder> & {
        index?: number;
    }): SchemaEntityWithId<TBuilder>;
    setEntityParent(entityId: string, parentId: string, options?: {
        index?: number;
    }): void;
    unsetEntityParent(entityId: string, options?: {
        index?: number;
    }): void;
    setEntityIndex(entityId: string, index: number): void;
    setEntityAttribute<TAttributeName extends KeyofUnion<InternalBuilderStoreEntity<TBuilder>["attributes"]>>(entityId: string, attributeName: TAttributeName, attributeValue: AttributesValues<TBuilder["entities"][number]["attributes"]>[TAttributeName]): void;
    deleteEntity(entityId: string): void;
    validateEntityAttribute<TAttributeName extends KeyofUnion<SchemaEntity<TBuilder>["attributes"]>>(entityId: string, attributeName: TAttributeName): Promise<void>;
    validateEntityAttributes(entityId: string): Promise<void>;
    validateEntitiesAttributes(): Promise<void>;
    resetEntityAttributeError<TAttributeName extends KeyofUnion<SchemaEntity<TBuilder>["attributes"]>>(entityId: string, attributeName: TAttributeName): void;
    setEntityAttributeError<TAttributeName extends KeyofUnion<SchemaEntity<TBuilder>["attributes"]>>(entityId: string, attributeName: TAttributeName, error?: unknown): void;
    resetEntityAttributesErrors(entityId: string): void;
    setEntityAttributesErrors(entityId: string, entityAttributesErrors: EntityAttributesErrors<TBuilder>): void;
    resetEntitiesAttributesErrors(): void;
    setEntitiesAttributesErrors(entitiesAttributesErrors: EntitiesAttributesErrors<TBuilder>): void;
    cloneEntity(entityId: string): void;
    validateSchema(): Promise<{
        data: Schema<TBuilder>;
        success: true;
    } | {
        reason: Extract<SchemaValidationErrorReason, {
            code: (typeof schemaValidationErrorCodes)["InvalidSchema"];
        }>;
        success: false;
    } | {
        reason: Extract<SchemaValidationErrorReason, {
            code: (typeof schemaValidationErrorCodes)["InvalidEntitiesAttributes"];
        }>;
        success: false;
    }>;
    setSchemaError(error?: unknown): void;
    resetSchemaError(): void;
    getEntity(entityId: string): SchemaEntityWithId<TBuilder> | null;
};

type EntityValue<TBuilder extends Builder = Builder> = Awaited<ReturnType<TBuilder["entities"][number]["validate"]>> | undefined;
type EntitiesValues<TBuilder extends Builder = Builder> = Record<string, EntityValue<TBuilder>>;
type EntitiesErrors = Record<string, unknown>;
type EntitiesValuesValidationResult<TBuilder extends Builder> = {
    data: EntitiesValues<TBuilder>;
    success: true;
} | {
    entitiesErrors: EntitiesErrors;
    success: false;
};
declare function validateEntitiesValues<TBuilder extends Builder>(entitiesValues: unknown, builder: TBuilder, schema: Schema<TBuilder>): Promise<EntitiesValuesValidationResult<TBuilder>>;

type InterpreterStoreData<TBuilder extends Builder = Builder> = {
    entitiesValues: EntitiesValues<TBuilder>;
    entitiesErrors: EntitiesErrors;
    unprocessableEntitiesIds: Array<string>;
};
declare const interpreterStoreEventsNames: {
    readonly EntityValueUpdated: "EntityValueUpdated";
    readonly EntityErrorUpdated: "EntityErrorUpdated";
    readonly EntityUnprocessable: "EntityUnprocessable";
    readonly EntityProcessable: "EntityProcessable";
    readonly DataSet: "DataSet";
};
type InterpreterStoreEventName = (typeof interpreterStoreEventsNames)[keyof typeof interpreterStoreEventsNames];
type InterpreterStoreEvent<TBuilder extends Builder = Builder> = SubscriptionEvent<typeof interpreterStoreEventsNames.EntityValueUpdated, {
    entityId: string;
    value: EntityValue<TBuilder>;
}> | SubscriptionEvent<typeof interpreterStoreEventsNames.EntityErrorUpdated, {
    entityId: string;
    error: unknown;
}> | SubscriptionEvent<typeof interpreterStoreEventsNames.EntityUnprocessable, {
    entityId: string;
}> | SubscriptionEvent<typeof interpreterStoreEventsNames.EntityProcessable, {
    entityId: string;
}> | SubscriptionEvent<typeof interpreterStoreEventsNames.DataSet, {
    data: InterpreterStoreData<TBuilder>;
}>;
type InterpreterStoreOptions<TBuilder extends Builder> = {
    initialData?: Partial<Omit<InterpreterStoreData<TBuilder>, "unprocessableEntitiesIds">>;
    initialEntitiesValuesWithDefaults?: boolean;
};
declare function createInterpreterStore<TBuilder extends Builder>(builder: TBuilder, schema: Schema<TBuilder>, options?: InterpreterStoreOptions<TBuilder>): InterpreterStore<TBuilder>;
type InterpreterStore<TBuilder extends Builder = Builder> = {
    getData(): InterpreterStoreData<TBuilder>;
    getEntitiesErrors(): InterpreterStoreData<TBuilder>["entitiesErrors"];
    getEntitiesValues(): InterpreterStoreData<TBuilder>["entitiesValues"];
    getUnprocessableEntitiesIds(): InterpreterStoreData<TBuilder>["unprocessableEntitiesIds"];
    setData(data: Omit<InterpreterStoreData<TBuilder>, "unprocessableEntitiesIds">): void;
    subscribe(...args: Parameters<Subscribe<InterpreterStoreData<TBuilder>, InterpreterStoreEvent<TBuilder>>>): ReturnType<Subscribe<InterpreterStoreData<TBuilder>, InterpreterStoreEvent<TBuilder>>>;
    builder: TBuilder;
    schema: Schema<TBuilder>;
    validateEntityValue(entityId: string): Promise<void>;
    validateEntitiesValues(): Promise<EntitiesValuesValidationResult<TBuilder>>;
    setEntityValue(entityId: string, value: EntityValue<TBuilder>): void;
    resetEntityValue(entityId: string): void;
    resetEntitiesValues(): void;
    clearEntityValue(entityId: string): void;
    clearEntitiesValues(): void;
    setEntityError(entityId: string, error: unknown): void;
    resetEntityError(entityId: string): void;
    resetEntitiesErrors(): void;
    setEntitiesErrors(entitiesErrors: InterpreterStoreData<TBuilder>["entitiesErrors"]): void;
    isEntityProcessable(entityId: string): boolean;
    getEntityValue(entityId: string): EntityValue<TBuilder> | undefined;
    getEntityError(entityId: string): unknown;
};

export { type Attribute, type AttributeContext, type AttributesValues, type Builder, type BuilderStore, type BuilderStoreData, type BuilderStoreEvent, type BuilderStoreEventName, type EntitiesAttributesErrors, type EntitiesErrors, type EntitiesValues, type Entity, type EntityAttributesErrors, type EntityContext, type EntityValue, type InterpreterStore, type InterpreterStoreData, type InterpreterStoreEvent, type InterpreterStoreEventName, type InterpreterStoreOptions, type Schema, type SchemaEntity, type SchemaEntityWithId, SchemaValidationError, type SchemaValidationErrorCode, type SchemaValidationErrorReason, type SubscriptionEvent, builderStoreEventsNames, createAttribute, createBuilder, createBuilderStore, createEntity, createInterpreterStore, interpreterStoreEventsNames, schemaValidationErrorCodes, validateEntitiesValues, validateSchema, validateSchemaShape };
